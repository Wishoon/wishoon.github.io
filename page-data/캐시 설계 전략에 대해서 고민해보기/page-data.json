{"componentChunkName":"component---src-templates-post-jsx","path":"/캐시 설계 전략에 대해서 고민해보기/","result":{"data":{"site":{"siteMetadata":{"title":"rookie"}},"markdownRemark":{"id":"9adaf203-e9ac-55e1-a772-b716b41c886a","excerpt":"온라인 면접만 보다가 최근 처음으로 오프라인 기술 면접을 보게 되었습니다. 기술 질문 중 분산 환경에서의 캐시의 정합성을 어떻게 보장할 것인가에 대한 내용이 나왔었고 어찌어찌 대답은 했지만 썩 만족할만큼 대답을 하진 못했던 것 같습니다. 이번 글을 통해서 캐시에 대해서 한번 살펴보고 어떻게 구현을 해야할지 고민해보는 시간을 가져보려고 합니다. 캐시 전략이…","html":"<p>온라인 면접만 보다가 최근 처음으로 오프라인 기술 면접을 보게 되었습니다. 기술 질문 중 분산 환경에서의 캐시의 정합성을 어떻게 보장할 것인가에 대한 내용이 나왔었고 어찌어찌 대답은 했지만 썩 만족할만큼 대답을 하진 못했던 것 같습니다. 이번 글을 통해서 캐시에 대해서 한번 살펴보고 어떻게 구현을 해야할지 고민해보는 시간을 가져보려고 합니다.</p>\n<h2>캐시 전략이란?</h2>\n<p>캐시 전략은 웹 서비스 환경에서 시스템 성능 향상을 기대할 수 있는 중요한 기술입니다. 일반적으로 캐시는 메모리를 사용하기 때문에 기준의 RDMBS 보다 훨씬 빠르게 데이터를 응답할 수 있어 서비스 이용자들에게 빠르게 서비스를 제공할 수 있습니다. 따라서 어느 종류의 데이터를 캐시에 저장할지, 얼만큼 데이터를 캐시에 저장할지에 대해 “캐시 지침 전략”을 고민해볼 필요가 있습니다.</p>\n<p>기본적으로 캐시를 호출하게 되면 <code class=\"language-text\">cache hit</code> 와 <code class=\"language-text\">cache miss</code>로 동작한다고 할 수 있습니다.</p>\n<ul>\n<li>cache hit : 캐시 스토어에 데이터가 있을 경우 바로 가져옴</li>\n<li>cache miss : 캐시 스토어에 데이터가 없을 경우 데이터베이스 에서 가져옴</li>\n</ul>\n<p>캐시를 사용하게 되면 반드시 고려해야 하는 문제가 있습니다. 바로 <strong>데이터 정합성</strong> 입니다.</p>\n<p>데이터 정합성이란, 어느 한 데이터가 캐시와 데이터베이스 두 곳에서 같이 관리되어 같은 데이터임에도 불구하고 <strong>데이터 정보값이 서로 다른 현상</strong>을 말합니다. 이전에는 그냥 데이터베이스에서 데이터 조회와 변경을 처리하였기 때문에 정합성 문제가 발생하지 않았지만, 캐시라는 다른 데이터 저장소를 이용하기 때문에 두 저장소에 저장된 값이 서로 다른 현상이 일어날 수 있는 것입니다.</p>\n<p>이러한 기본 개념을 바탕으로 캐시 전략을 어떻게 수립할지 각 패턴에 대해서 한번 살펴보도록 하겠습니다.</p>\n<h2>캐시 전략의 패턴</h2>\n<h3>캐시 읽기 전략 - Cashe Aside 패턴</h3>\n<p>데이터를 찾을 때 <strong>우선 캐시에 저장된 데이터가 있는지 우선적으로 확인하는 전략</strong>을 말합니다. 만일 캐시에 데이터가 없을 경우 DB에서 조회를 하는 방식으로 동작합니다.</p>\n<p>읽기가 많은 경우에 적합하며, 가용성 측면에서 Cache 서버에 장애가 발생해도 데이터베이스를 통해 문제 없이 서비스를 운용할 수 있습니다. 다만 캐시에 붙어있는 Connection이 많다면 데이터베이스에 부하가 발생하는 문제가 생길 수 있습니다. 또한 Cashe 서버와 데이터베이스 간의 데이터 정합성 문제가 발생할 수 있으며, 초기 요청은 반드시 데이터베이스를 호출해야 하는 단점이 있습니다.</p>\n<p>이 때문에 반복적으로 동일 쿼리를 수행하는 서비스에 적합한 아키텍처라고 할 수 있습니다.</p>\n<h3>캐시 읽기 전략 - Read Through 패턴</h3>\n<p>데이터를 찾을 때 <strong>무조건 캐시에서만 데이터를 읽어오는 전략</strong>을 말합니다. 만일 캐시에 데이터가 없을 경우 DB에서 조회를 하는 방식으로 동작합니다. Cashe Aside와 비슷하지만 데이터 동기화를 라이브러리 혹은 캐시 제공자에게 위임하는 방식이 차이점이 있습니다.</p>\n<p>읽기가 많은 경우에 적합하며, 캐시와 데이터베이스의 데이터 정합성이 보장되기 때문에 정합성에 대한 고민을 하지 않고 서비스를 운용할 수 있습니다. 다만 캐시가 문제가 발생했을 경우 서비스 전체가 중단되어 버리는 문제가 발생할 수 있습니다. 이 때문에 캐시 스토어를 가용성 측면에서 Replication과 Cluster로 구성하여 문제가 없도록 설계해야 합니다.</p>\n<p>즉, 반복적으로 동일 쿼리를 수행하는 서비스 중 정합성이 보장되어야 하는 서비스에 적합한 아키텍처라고 할 수 있습니다.</p>\n<h3>캐시 쓰기 전략 - Write Back 패턴</h3>\n<p>데이터를 저장할 때 <strong>데이터베이스에 바로 저장하지 않고 캐시에 모아서 일정 주기로 배치 작업을 수행해서 데이터베이스에 반영하는 전략</strong>을 말합니다.</p>\n<p>한번에 데이터를 저장하기 때문에 쓰기 쿼리 커넥션의 회수 비용과 부하를 줄일 수 있어 쓰기가 빈번하면서 일기 작업시 많은 양의 자원이 소모되는 서비스에 적합하다고 할 수 있습니다. 또한 서버는 캐시만 바라보고 있기 때문에 데이터 정합성을 확보할 수 있습니다. 다만 캐시에서 오류가 발생할 경우 서비스 전체가 중단되는 문제가 있습니다. 이 때문에 캐시 스토어를 가용성 측면에서 <code class=\"language-text\">Replicaiton</code>과 <code class=\"language-text\">Cluster</code>로 구성하여 문제가 없도록 설계해야 합니다. 또한 자주 사용되지 않는 데이터가 저장되어 캐시의 리소스 낭비가 발생할 수 있기 때문에 <code class=\"language-text\">TTL</code>을 유의미하게 사용해야 합니다.</p>\n<p>즉, 쓰기가 빈번하고 읽기 작업에 많은 리소스가 소모되면서 정합성이 보장되어야 하는 서비스에 적합한 아키텍처라고 할 수 있습니다.</p>\n<h3>캐시 쓰기 전략 - Write Through 패턴</h3>\n<p>데이터를 저장할 때 <strong>캐시와 데이터베이스에 동시에 데이터를 저장하는 전략</strong>을 말합니다.</p>\n<p>캐시와 데이터베이스가 항상 동기화 되어 있어, 캐시의 데이터는 항상 최신 상태로 유지되기 때문에 안정적으로 데이터 정합성을 확보해야 하는 서비스에 적합하다고 할 수 있습니다. 다만 매번 두번의 쓰기 요청이 발생하기 때문에 빈번한 수정, 생성이 발생하는 서비스에서는 성능 이슈가 발생할 수 있습니다. 다만 자주 사용되지 않는 데이터가 저장되어 캐시의 리소스 낭비가 발생할 수 있기 때문에 <code class=\"language-text\">TTL</code>을 유의미하게 사용해야 합니다.</p>\n<p>즉, 안정적으로 데이터 정합성을 보장해야 하는 서비스에 적합한 아키텍처라고 할 수 있습니다.</p>\n<h3>캐시 쓰기 전략 - Write Around 패턴</h3>\n<p>데이터를 저장할 때 데이터베이스에 데이터를 저장하는 전략을 말합니다.</p>\n<p>캐시를 거치지 않기 때문에 속도가 매우 빠릅니다. 하지만 <code class=\"language-text\">cashe miss</code>가 발생해야만 데이터베이스와 동기화를 수행하기 때문에, 캐시와 데이터베이스간의 불일치가 발생할 수 있습니다. 이 때문에 저장된 데이터가 수정, 삭제될 때마다 캐시 또한 삭제하거나 변경하는 작업을 수행해야 하며, 캐시의 <code class=\"language-text\">Expire</code>를 짧게 조정하는 하도록 설계해야 합니다.</p>\n<p>즉, 데이터가 한 번 쓰여지고, 덜 자주 읽어지는 서비스에 적합한 아키텍처라고 할 수 있습니다.</p>\n<h2>캐시 전략 조합해보기</h2>\n<p>일반적으로는 <code class=\"language-text\">Lock Aside</code> + <code class=\"language-text\">Write Around</code>를 사용하지만 정확성 보장이 되지 않습니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/923cd5ad703d6d2ab9fcb866c63fadf1/f97d7/img.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 33.529411764705884%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA3ElEQVQoz4WRAW+DIBCF+f9/0dSVVTrNag0osCLwdkdXh1uzveTLhVMej0PknPGAtVvn+zqm+IOEeZ5hrS11WRYk6rEEvlQb1Qdor+GC2+HXD5zPCu3hAPkq0bZtMS+GD+dnYlM2/EsmmN3/omkaSCnhvYdzbqvGGHRdh5fjEcMwwFuDWY9YzPWOvsJM73DUr28kQghgOGmMcWNd14K9XErN9D1RP9EMuVKDI9FM9G5kAv8o0YZMqVMFbjdYegylFNTphGmavhM+e4xfUKIaTuZpLH3f440Yx3Ez/AQFLyP0ZsspzgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img' title='img' src='/static/923cd5ad703d6d2ab9fcb866c63fadf1/ca1dc/img.png' srcset='/static/923cd5ad703d6d2ab9fcb866c63fadf1/e7570/img.png 170w,\n/static/923cd5ad703d6d2ab9fcb866c63fadf1/f46e7/img.png 340w,\n/static/923cd5ad703d6d2ab9fcb866c63fadf1/ca1dc/img.png 680w,\n/static/923cd5ad703d6d2ab9fcb866c63fadf1/02d09/img.png 1020w,\n/static/923cd5ad703d6d2ab9fcb866c63fadf1/9d567/img.png 1360w,\n/static/923cd5ad703d6d2ab9fcb866c63fadf1/f97d7/img.png 2000w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>이러한 내용을 보안하기 위해 <code class=\"language-text\">Read Through</code> + <code class=\"language-text\">Write Around</code> 조합을 통해 데이터 정합성 이슈에 대한 안정 장치를 구성할 수 있습니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/8f00f38e730dcbcdca837994f9aad9f2/f97d7/img_1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 35.29411764705882%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4UlEQVQoz32R23LDIAxE/f+f2HY8qXnwU6bhfhVbIceuk0nKzFpgkDhaJvDovR/a1+dIndCoHRrrWitSSsi5IKaI1pqcnc7Jz+KPJNvkkGpCKJEVkFvG9eeKeZ6hlMLXxye00X8F96KvRm0Vrri3+9YbkE0H1DQm67rKbd57aSPGKDLGCMHl+4KbvgmZzx7xTuqHokML+bHg6D/nDCKS+a7hU+H/0XES73EvbAFrxDPmZt9W8L9276dATN7HhSGAuANi+qo11KI2H5dFYMTDdw/yoEHHxGdRKbDWQnPhEXewX7eMJXVssM8BAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img 1' title='img 1' src='/static/8f00f38e730dcbcdca837994f9aad9f2/ca1dc/img_1.png' srcset='/static/8f00f38e730dcbcdca837994f9aad9f2/e7570/img_1.png 170w,\n/static/8f00f38e730dcbcdca837994f9aad9f2/f46e7/img_1.png 340w,\n/static/8f00f38e730dcbcdca837994f9aad9f2/ca1dc/img_1.png 680w,\n/static/8f00f38e730dcbcdca837994f9aad9f2/02d09/img_1.png 1020w,\n/static/8f00f38e730dcbcdca837994f9aad9f2/9d567/img_1.png 1360w,\n/static/8f00f38e730dcbcdca837994f9aad9f2/f97d7/img_1.png 2000w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>정말 정합성이 중요한 서비스라면, 항상 캐시에 데이터를 먼저 쓰는 방식인 <code class=\"language-text\">Read Through</code> + <code class=\"language-text\">Write Through</code> 방식을 통해 완전하게 데이터 정합성 문제를 해결하는 방법을 선택할 수 있습니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/f5bde0f34a73e011b22eb8925a3877a3/f97d7/img_2.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 33.529411764705884%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAw0lEQVQoz41RDQuDIBTs///DILTGWBDLzPzAMm9puJVrsIPj0KfPe2fhvUdiwFFzYi9FkVJCa/3WdK/AAV8NMmy70FaBPR+41zXoxubWgBAC59zecF3XuLhqEGqBoTbIHpPoYSYOZ8x+wC0Qhp8MFV3XoSxLCCFgrY32zXZBKYW2bUEpjWqNhF+Wg1tgDiOrETGNNHJymPQX81gitkfnWZ+yL/An8mzHcQSpqjgBY+wz8tVvXv5w5i7EwznHMAwxnlR/AXiEJaUa+cKJAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img 2' title='img 2' src='/static/f5bde0f34a73e011b22eb8925a3877a3/ca1dc/img_2.png' srcset='/static/f5bde0f34a73e011b22eb8925a3877a3/e7570/img_2.png 170w,\n/static/f5bde0f34a73e011b22eb8925a3877a3/f46e7/img_2.png 340w,\n/static/f5bde0f34a73e011b22eb8925a3877a3/ca1dc/img_2.png 680w,\n/static/f5bde0f34a73e011b22eb8925a3877a3/02d09/img_2.png 1020w,\n/static/f5bde0f34a73e011b22eb8925a3877a3/9d567/img_2.png 1360w,\n/static/f5bde0f34a73e011b22eb8925a3877a3/f97d7/img_2.png 2000w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h2>캐시 저장 방식 지침</h2>\n<p>캐시 솔루션은 자주 사용되면서 자주 변경되지 않는 데이터의 경우 캐시 스토어에 적용하여 반영할 경우 높은 성능 향상을 이뤄낼 수 있습니다. 이를 <code class=\"language-text\">Cashe Hit Rating</code> 이라고 합니다.</p>\n<p>또한 캐시를 저장하는 곳이 <strong>메모리이기 때문에 휘발될 수 있다는 점에 주의</strong>를 해야합니다.</p>\n<p>이러한 내용들을 바탕으로 캐시 스토어에 저장되는 내용은 중요한 정보, 민감 정보등은 저장하지 않는 것이 좋으며, 캐시 스토어가 장애가 발생했을 경우 대응할 수 있는 방안을 고려하여 설계하는 것이 바람직 합니다.</p>\n<h2>캐시 삭제 방식 지침</h2>\n<p>캐시에 저장된 데이터의 경우 캐시 서버에만 단독으로 저장되는 경우도 있을 수 있지만, 대부분의 경우 영구 저장소에 저장된 데이터를 바탕으로 하여 복사된 데이터를 기준으로 동작하는 경우가 많습니다. 즉, 영구 저장소의 데이터와 캐시 스토어의 데이터를 동기화 하는 작업이 반드시 필요하다고 할 수 있습니다.</p>\n<p>만약 캐시의 만료 정책이 제대로 구현되지 않은 경우 클라이언트는 데이터가 변경되었음에도 오래된 정보가 캐싱되어 있어 데이터 정합성이 맞지 않는 문제가 발생할 수 있다고 할 수 있습니다.</p>\n<p>따라서 캐시를 구성할 때는 기본 만료 정책을 구성해야 하며, 캐시된 데이터가 기간이 만료되면 데이터를 제거하고 원래의 영구 저장소에서 데이터를 검색해서 사용자에게 제공해야 합니다. 추가적으로 고려해야 할 점은 캐시의 만료 주기가 너무 짧으면 캐시를 사용하는 이점이 줄어들기 때문에 시스템에 맞게 적절한 만료주기를 구성하여 적용하는 것이 바람직 합니다.</p>\n<h2>캐시 공유 방식 지침</h2>\n<p>보통 분산 환경에서 어플리케이션을 운용하기 때문에 캐시는 여러 인스턴스에서 공유되어 사용됩니다. 이 때문에 각 어플리케이션에서 캐시의 데이터를 읽고 수정할 수 있습니다. 따라서 <strong>캐시에 보관되어 있는 데이터 정합성에 문제가 발생</strong>할 수 있습니다.</p>\n<p>이를 해결하기 위해서 첫 번째로 고민한 방식은 캐시 데이터를 변경하기 직전에 데이터가 검색된 이후 변경되지 않았는지 확인하는 방법입니다. 변경되지 않았다면 즉시 업데이트를 하고, 변경되었다면 업데이트 여부를 애플리케이션 레벨에서 결정하도록 수정하는 방식을 취할 수 있습니다.</p>\n<p>해당 방식은 업데이트가 적게 발생하고, 충돌이 잘 발생하지 않는 상황에서 적용하기 용이하다고 할 수 있습니다.</p>\n<p>두 번째로 고민한 방법은 캐시 데이터를 업데이트 하기 전에 Lock을 잡는 방식입니다. 해당하는 경우 조금 더 안전하게 정합성 문제를 해결할 수 있지만 Lock으로 인해 대기현상이 발생하게 됩니다.</p>\n<p>해당 방식은 데이터의 사이즈가 작아 빠르게 업데이트가 가능한 업무와 빈번한 업데이트가 발생하는 상황에 적용하기 용이하다고 할 수 있습니다.</p>\n<h2>마무리..</h2>\n<p>기본적으로 캐시에 대해서 어떻게 사용해야 하는지, 전략은 어떤 방식이 있는지 알아볼 수 있는 시간이였습니다. 이후로는 단일 서버와 분산 서버 환경에서 어떻게 캐시를 구현하는지, 가용성을 올리기 위해서는 어떤 부분을 고민해야 하는지를 계속 학습해보려고 합니다.</p>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-%EC%BA%90%EC%8B%9CCache-%EC%84%A4%EA%B3%84-%EC%A0%84%EB%9E%B5-%EC%A7%80%EC%B9%A8-%EC%B4%9D%EC%A0%95%EB%A6%AC\">https://inpa.tistory.com/entry/REDIS-📚-캐시Cache-설계-전략-지침-총정리</a></li>\n<li><a href=\"https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cache-aside\">https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cache-aside</a></li>\n<li><a href=\"https://dzone.com/articles/using-read-through-amp-write-through-in-distribute\">https://dzone.com/articles/using-read-through-amp-write-through-in-distribute</a></li>\n<li><a href=\"https://brunch.co.kr/@springboot/151\">https://brunch.co.kr/@springboot/151</a></li>\n</ul>","frontmatter":{"title":"캐시 설계 전략에 대해서 고민해보기","date":"December 08, 2022","update":"December 08, 2022","tags":["Cache"],"series":null},"fields":{"slug":"/캐시 설계 전략에 대해서 고민해보기/","readingTime":{"minutes":16.315}}},"seriesList":{"edges":[{"node":{"id":"863212f2-1cb1-5101-804a-5416ffb5b9d3","fields":{"slug":"/Nginx와-Gzip을-활용한-프론트-최적화/"},"frontmatter":{"title":"Nginx와 Gzip을 활용한 프론트 최적화"}}},{"node":{"id":"4c21b76a-ad6b-5e0b-b0e7-a0c0e94b12a9","fields":{"slug":"/Replication과-SpringBoot/"},"frontmatter":{"title":"Replication과 Spring Boot"}}},{"node":{"id":"aae5e42a-02b5-56c8-8475-67f77087a495","fields":{"slug":"/JPA를-사용함으로서-겪었던-문제들/"},"frontmatter":{"title":"JPA를 사용함으로서 겪었던 문제들"}}},{"node":{"id":"948cec5b-7366-505a-992f-1dd680a012ee","fields":{"slug":"/테스트에서의 @Transactional/"},"frontmatter":{"title":"테스트에서의 @Transactional"}}},{"node":{"id":"c4eb0572-f278-5d08-9052-32b5b549b9bb","fields":{"slug":"/DAO와-Repository/"},"frontmatter":{"title":"DAO와 Repository"}}},{"node":{"id":"9adaf203-e9ac-55e1-a772-b716b41c886a","fields":{"slug":"/캐시 설계 전략에 대해서 고민해보기/"},"frontmatter":{"title":"캐시 설계 전략에 대해서 고민해보기"}}},{"node":{"id":"c20ecd3e-8f83-53ad-89dd-dc937758fc6e","fields":{"slug":"/현재 시간을 검증해야 하는 로직 개선에 대해 고민해보기/"},"frontmatter":{"title":"현재 시간을 검증해야 하는 로직 개선에 대해 고민해보기"}}}]},"previous":{"fields":{"slug":"/동시성 문제 해결을 통한 제고 시스템 구현하기 - 2/"},"frontmatter":{"title":"동시성 문제 해결을 통한 제고 시스템 구현하기 - 2"}},"next":{"fields":{"slug":"/현재 시간을 검증해야 하는 로직 개선에 대해 고민해보기/"},"frontmatter":{"title":"현재 시간을 검증해야 하는 로직 개선에 대해 고민해보기"}}},"pageContext":{"id":"9adaf203-e9ac-55e1-a772-b716b41c886a","series":null,"previousPostId":"be19031d-0087-5686-bf06-7c650304fa77","nextPostId":"c20ecd3e-8f83-53ad-89dd-dc937758fc6e"}},"staticQueryHashes":[]}