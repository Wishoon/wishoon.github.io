{"componentChunkName":"component---src-templates-post-jsx","path":"/동시성 문제 해결을 통한 제고 시스템 구현하기 - 1/","result":{"data":{"site":{"siteMetadata":{"title":"rookie"}},"markdownRemark":{"id":"e0a5e2ef-ea28-5a38-8c0f-8b271b39bee8","excerpt":"재고를 기반으로 운영되는 쿠폰 시스템은 개발자가 고려해야 할 점이 많습니다. 현재 개발되고 있는 프로젝트는 자바와 스프링을 기반으로 한 웹 어플리케이션으로 운용되고 있습니다. 이러한 어플리케이션은 기본적으로 멀티 스레드 환경에서 구동이 되기 때문에 공유 자원에 대한 경쟁 상태가 발생하지 않도록 주의를 기울여 개발을 해야 합니다. 이러한 문제를 해결하기 위…","html":"<p>재고를 기반으로 운영되는 쿠폰 시스템은 개발자가 고려해야 할 점이 많습니다. 현재 개발되고 있는 프로젝트는 자바와 스프링을 기반으로 한 웹 어플리케이션으로 운용되고 있습니다. 이러한 어플리케이션은 기본적으로 멀티 스레드 환경에서 구동이 되기 때문에 공유 자원에 대한 경쟁 상태가 발생하지 않도록 주의를 기울여 개발을 해야 합니다.</p>\n<p>이러한 문제를 해결하기 위해 우리는 다양한 부분에 대해서 고민을 해볼 필요성이 있습니다. 그 중의 하나가 데이터베이스의 상태를 변화시키는 작업의 단위라고 불리는 <code class=\"language-text\">트랜잭션</code> 이라고 생각합니다. 이번 글에서는 트랜잭션의 관점에서 어떻게 동시성 문제를 해결하는지 살펴보고, Spring에서는 어떻게 트랜잭션을 지원하는지 그 개념과 동작원리를 살펴보는 시간을 가져보려고 합니다.</p>\n<h2>Transactional의 개념과 격리레벨</h2>\n<h3>트랜잭션이란?</h3>\n<p><strong>트랜잭션은 데이터베이스 상태를 변화시키는 하나의 논리적인 작업기능을 구성하는 단위</strong>를 말합니다. 어떤 작업들이 성공적으로 완료되어야 구성된 작업의 결과를 반영하고, 오류가 발생했을 때는 이전에 있었던 모든 작업들이 성공적이라고 해도 없었던일 처럼 완전히 되돌리는 것이 트랜잭션의 개념이라고 할 수 있습니다.</p>\n<p>이러한 트랜잭션을 수행함에 있어서 동시에 여러 트랜잭션이 변경을 수행할 때 일관성을 유지하는 기능을 제공하고 안정성과 성능을 조절하기 위해서 필요한 설정이 바로 트랜잭션의 격리 레벨이라고 할 수 있습니다.</p>\n<h3>트랜잭션의 격리 레벨이란 무엇인가?</h3>\n<p>트랜잭션 격리 레벨이란 앞서서 말했듯이 <strong>동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것</strong>입니다. 즉, 특정 트랜잭션이 다른 트랜잭션에 변경할 데이터를 볼 수 있도록 허용할지 말지를 결정합니다.</p>\n<p>이를 수행하기 위해서, 트랜잭션이 독립적인 수행을 하도록 <code class=\"language-text\">Locking</code>을 통해, 하나의 트랜잭션이 데이터베이스를 다루는 동안 다른 트랜잭션이 해당 트랜잭션에 관여하지 못하도록 막는 작업이 필요합니다.</p>\n<p>하지만 무조건적인 <code class=\"language-text\">Locking</code>으로 동시에 수행되는 수많은 트랜잭션을 순서대로 처리하도록 설계하게 되면 데이터베이스의 동시성 성능이 떨어지게 됩니다. 이러한 성능저하를 줄이기 위해서 <code class=\"language-text\">Locking</code>의 범위를 줄인다면, 데이터 일관성이 깨지는 문제가 발생할 수도 있습니다. 따라서 최대한 효율적으로 <code class=\"language-text\">Locking</code> 설정하는 것이 좋습니다.</p>\n<h3>Locking Reads</h3>\n<p>기본적으로 <code class=\"language-text\">SELECT</code>문을 통해 데이터를 조회하게 되면 <code class=\"language-text\">Non-Locking</code> 상태라고 할 수 있습니다. 때문에 읽기 작업과 쓰기 작업이 하나의 트랜잭션에서 같이 발생되는 경우 다른 트랜잭션에 의해 변경될 가능성이 있습니다. InnoDB에서는 이러한 문제를 해결하기 위해 <code class=\"language-text\">FOR SHARE</code>, <code class=\"language-text\">FOR UPDATE</code> 라는 <code class=\"language-text\">Locking Reads</code>를 제공합니다.</p>\n<p><strong><code class=\"language-text\">SELECT … FOR SHARE</code></strong> 는 조회하는 인덱스 레코드에 <code class=\"language-text\">S-Lock</code> 을 설정합니다. 다른 트랜잭션에서 레코드를 읽을 수는 있지만, <code class=\"language-text\">S-Lock</code>을 설정한 트랜잭션이 커밋되기 전까지 레코드를 수정할 수 없으며, <code class=\"language-text\">X-Lock</code>을 설정할 수 없습니다.</p>\n<p><strong><code class=\"language-text\">SELECT … FOR UPDATE</code></strong> 는 조회하는 인덱스 레코드에 대해 <code class=\"language-text\">UPDATE</code> 문을 실행한 것과 동일하게 레코드 및 관련 인덱스에 <code class=\"language-text\">X-Lock</code>을 설정합니다. 다른 트랜잭션에서 레코드를 읽거나 쓰는 작업이 불가능하며, <code class=\"language-text\">S-Lock</code>이나 <code class=\"language-text\">X-Lock</code>을 설정할 수 없습니다.</p>\n<p>이러한 <code class=\"language-text\">Locking Reads</code>를 바탕으로 <code class=\"language-text\">Locking</code>을 구현하게 됩니다.</p>\n<h3>Locking과 Consistent Read</h3>\n<p>InnoDB에서 기본적으로 <code class=\"language-text\">Locking</code>은 트랜잭션의 격리 수준을 구현되기 위해서 사용됩니다. 이를 구현하기 위한 대표적인 방법으로 <strong>Record Lock, Gap Lock, Next-Key Lock</strong>을 살펴보고자 합니다.</p>\n<p><strong><code class=\"language-text\">Record Lock</code></strong> 은 하나의 인덱스 레코드에만 Lock을 거는 것을 말합니다. 만약 테이블에 인덱스가 정의되지 않았다고 하더라도 InnoDB를 기준으로 primary key 혹은 unique key를 통해서 Clustered Index를 생성하기 때문에 이를 활용하여 Record Lock을 적용할 수 있습니다.</p>\n<p>만약 <code class=\"language-text\">SELECT content FROM coupon WHERE id = 1 FOR UPDATE;</code> 와 같은 쿼리를 실행하게 된다면 id가 1에 해당하는 레코드에 Record Lock이 설정되기 때문에 다른 트랜잭션에서 해당 레코드를 변경할 수 없습니다.</p>\n<p><strong><code class=\"language-text\">Gap Lock</code></strong> 은 인덱스 레코드간의 범위에 Lock을 거는 것을 말합니다. 최초 레코드 이전, 마지막 레코드 이후를 가상의 인덱스 레코드로 생각해서 Lock을 설정할 수 있으며, 다른 트랜잭션에서 해당 범위에 데이터를 삽입하거나 변경할 수 없습니다.</p>\n<p>만약 <code class=\"language-text\">SELECT content FROM coupon WHERE id ≥ 1 FOR UPDATE;</code> 와 같은 쿼리를 실행하고 다른 트랜잭션이 id가 10인 데이터를 삽입하려고 한다면, 해당 id 값은 Gap Lock으로 설정되어 있기 때문에 삽입하거나 혹은 변경할 수 없습니다.</p>\n<p><strong><code class=\"language-text\">Next Key-Lock</code></strong> 은 Record Lock과 해당 인덱스 레코드 앞의 Gap에 대한 Gap Lock을 조합하여 Lock을 거는 것을 말합니다.</p>\n<p>이렇게 <code class=\"language-text\">Locking</code>이 설정됨에 따라서 격리 수준을 구현할 수 있게 되었지만 동시성 성능은 떨어지게 되었습니다. MySQL의 InnoDB는 이렇게 동시성 성능이 떨어지는 문제를 해결하기 위해서 <code class=\"language-text\">MVCC</code>라는 개념을 도입하였습니다. 이는 각 트랜잭션의 격리 레벨에 따라 상이하지만, 특정 시점의 <code class=\"language-text\">Snapshot</code> 정보를 바탕으로 하여, 기존과 같이 <code class=\"language-text\">Locking</code>을 사용하지 않고도 <code class=\"language-text\">일관된 읽기(Consistent Read)</code>를 제공하여 동시성을 제어할 수 있게 됩니다.</p>\n<h2>트랜잭션 격리 레벨에 대해서 자세히 알아보자</h2>\n<p>지금까지의 내용들을 바탕으로 트랜잭션 격리 레벨을 구성할 수 있으며 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 총 4단계로 구분할 수 있습니다.</p>\n<p>그러면 4가지 키워드들에 대해서 하나씩 살펴보도록 하겠습니다.</p>\n<h3>READ UNCOMMITTED</h3>\n<p><code class=\"language-text\">Read Uncommitted</code>는 커밋 전의 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 읽는 것을 허용하는 격리 레벨을 말합니다. <code class=\"language-text\">Read Uncommitted</code> 에서는 일반적인 SELECT 문은 Non-Locking Read로 수행되지만 MVCC를 사용하지 않아 Consistent Read를 보장하지 않습니다.</p>\n<p><code class=\"language-text\">Read Uncommitted</code> 에서는  <code class=\"language-text\">Dirty Read</code>현상이 발생할 수 있습니다. <code class=\"language-text\">Transaction 1</code>에서 INSERT로 추가된 <code class=\"language-text\">Coupon</code>이 <code class=\"language-text\">COMMIT</code> 되기 이전에 새로운 <code class=\"language-text\">Transaction 2</code>에서 <code class=\"language-text\">Coupon</code>을 조회한다고 가정해보겠습니다. 하지만 <code class=\"language-text\">Transaction 1</code>에서 오류가 발생해서 <code class=\"language-text\">ROLLBACK</code>이 되게 되었습니다. 이 경우 <code class=\"language-text\">Transaction 2</code>는 <code class=\"language-text\">ROLLBACK</code> 여부를 확인하지 못하고 <code class=\"language-text\">ROLLBACK</code> 된 <code class=\"language-text\">Coupon</code>를 정상적인 데이터라 생각하고 작업을 계속 진행하게 됩니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/1c58f2297bbd2ee4528da955e586337f/c1e63/img.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 69.41176470588235%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWElEQVQ4y5WTcY+CMAzF/f7fzz88LhEvAQkiCIKAoHW/Jl244SVek2ZvrH3rXsvm+XwK9ng8xPAnZrHLHPDGNsfjUS6Xi9zvdxmGQX0cR+n7Xr+BzUMyzud5VqyE0zRJXddyu9300EjLspT9fi9N0yjebreS57lP5lUYl8LhCTlIkkSKovBVdV2neFktpGAIl09dEbKhqtC4yLRdrmZVVYnlrwi5xXQx/8uoMssyOcSxrhCvNCQo7F7btprAGRhZrteraho7stTtM9fMjwj5RtdpAg0DQ3I+n708Fju80zAkRCvTlpUKmAKTB9w7z6Mvyb4jr+1bwv8MODa63FWFjEXYFKsyxOi52+0kdjNKY5az6QmZu2VlEDCX6IZ+4CiKNJlYdK3dXELeOF8NdpqmmoQ+OIGsSGErxHauv6PzJk3k9HP4XWH4THOCbLW/w76Zt8VJuqr0cr0AWyJHCzi8MkAAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img' title='img' src='/static/1c58f2297bbd2ee4528da955e586337f/ca1dc/img.png' srcset='/static/1c58f2297bbd2ee4528da955e586337f/e7570/img.png 170w,\n/static/1c58f2297bbd2ee4528da955e586337f/f46e7/img.png 340w,\n/static/1c58f2297bbd2ee4528da955e586337f/ca1dc/img.png 680w,\n/static/1c58f2297bbd2ee4528da955e586337f/02d09/img.png 1020w,\n/static/1c58f2297bbd2ee4528da955e586337f/9d567/img.png 1360w,\n/static/1c58f2297bbd2ee4528da955e586337f/c1e63/img.png 1680w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>이처럼 트랜잭션에서 처리한 작업이 완료되지 않아도 볼 수 있는 현상을 <code class=\"language-text\">Dirty Read</code> 현상을 확인할 수 있습니다.</p>\n<h3>READ COMMITTED</h3>\n<p><code class=\"language-text\">Read Committed</code>는 <code class=\"language-text\">COMMIT</code>이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회가 가능합니다. 이로 인해서 <code class=\"language-text\">Read Uncommitted</code>에서 발생하는 <code class=\"language-text\">Dirty Read</code>가 발생하지 않습니다. 이렇게 되는 이유는 <code class=\"language-text\">Read Committed</code> 부터는 <code class=\"language-text\">MVCC</code>인 <code class=\"language-text\">Consistent Read</code>로 문제를 해결하기 때문입니다.</p>\n<p><code class=\"language-text\">Read Committed</code>에서 데이터의 변경이 일어나게 되면 변경 전 데이터는 <strong>언두 영역으로 복사가 됩니다</strong>. 그리고 <strong>다른 트랜잭션에서 해당 테이블의 데이터를 조회할 경우, 변경된 테이블 데이터를 조회하는 것이 아니라 언두 영역에 복사된(Snapshot) 레코드를 조회</strong>하게 됩니다. 이 때문에 발생할 수 있는 문제를 해결할 수 있습니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/70f38cbbad9f0e4729e7d1b5abb1f338/c1e63/img_1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 69.41176470588235%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcklEQVQ4y42T6Y7CMAyEef/3Q/wAlkM9OAq9aGlLqTefhVFaVmgjWXESezwTJ7NhGITxfD7F/P8Mi/Vz8Ge2iONYsiyTruukaRq1tm3lfr/rHr7ZFIzzvu/VV8DH4yF5nktd13pooNfrVTabjRRFof58PpfT6fRONkCKgvEGRG4YhpIkiQIRUFXViBVF0jTVcwB9qeyNAH3K/qAQZyTjk+THocjyR4AEUR1pVDOwy+Ui2+1WrwP2y+VSJcOYK/hZr3VN3ggQBrvdThOiKJLb7aaSrTkwYaYAYMyr1UqC/V7CINBiH00xZr48gGF3OBzkeDwqk7IspXpJtdG62BHDKaBJ5hpoFkCwWiwWyubs9nKnpHCFSmdJGHxn6DP1H/3wWtdZKlkcOYuldHeYurn/xtA3zgwcFlbEH91fkrl4/22RiDy6zA/CpxHcpcrzGH88bAII5ClwiNEQZppgezSHefpTPh62LxFmZiT6ZnvTv2y5jF+6SkToUd4HywAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img 1' title='img 1' src='/static/70f38cbbad9f0e4729e7d1b5abb1f338/ca1dc/img_1.png' srcset='/static/70f38cbbad9f0e4729e7d1b5abb1f338/e7570/img_1.png 170w,\n/static/70f38cbbad9f0e4729e7d1b5abb1f338/f46e7/img_1.png 340w,\n/static/70f38cbbad9f0e4729e7d1b5abb1f338/ca1dc/img_1.png 680w,\n/static/70f38cbbad9f0e4729e7d1b5abb1f338/02d09/img_1.png 1020w,\n/static/70f38cbbad9f0e4729e7d1b5abb1f338/9d567/img_1.png 1360w,\n/static/70f38cbbad9f0e4729e7d1b5abb1f338/c1e63/img_1.png 1680w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>하지만 <code class=\"language-text\">Read Committed</code>는 <code class=\"language-text\">COMMIT</code> 된 데이터에 대해서는 정합성을 유지한다는 판단을 하기 때문에 <code class=\"language-text\">Commit</code>이 발생할 경우 기존 <code class=\"language-text\">Snapshot</code>을 새로운 <code class=\"language-text\">Snapshot</code>으로 다시 덮어쓰게 됩니다. 이 때문에 <code class=\"language-text\">Read Committed</code>에서는 <code class=\"language-text\">None Repetable Read</code>현상이 발생할 수 있습니다.</p>\n<p>DB에는 <code class=\"language-text\">Coupon</code>이 2개가 있다고 가정해보겠습니다. <code class=\"language-text\">Transaction 1</code>에서 쿼리가 먼저 시작되고 나서 <code class=\"language-text\">Transaction 2</code>에서 <code class=\"language-text\">Coupon</code> 의 2번 ID를 조회하면 <strong>커피가 조회가 되게 됩니다</strong>. 하지만 <code class=\"language-text\">Transcation 1</code>에서 <strong>UPDATE</strong> 쿼리가 <code class=\"language-text\">COMMIT</code> 된 이후 <code class=\"language-text\">Transaction 2</code> 에서 다시 똑같은 <strong>SELECT</strong> 쿼리를 사용하여 다시 <code class=\"language-text\">Coupon</code>를 조회하게 될 경우 <strong>UPDATE</strong> 쿼리의 경우 <strong>술이 조회가 되게 됩니다.</strong></p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/71d0a5f25c77b56741a5b781c61a53df/c1e63/img_2.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 69.41176470588235%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABmUlEQVQ4y41T686CMAz1/d/P+AP9vAByR9i4i9SexpqhifmWNHRbe3pOOzbLshDW4/Eg9f+zNNbNgb/RTRRFVFUVTdNEwzCIjeNIfd/LGXy1TzDcz/MsvgDe73eq65q6rpNLBS3Lko7HIxljxN9ut5Sm6TtZAVEUGG9AyA3DkPI8FyAEtG27YoUit9tN7gHoSsXZCtCl7C4Uwh2S4SPJjYMizV8BIgjVIQ3VFKwoCjqdTtIOsPc8TySDMVrwdzjIHnkrQDA4n8+ScL1eqWkakazDARN8UQBg+O73ewouFwqDQIp9DUWZufIADHZxHFOSJMLEWkvtS6qukWNXDD8BVTLagGEBCKx2u52wycKAalZiuJCJI8qZ5U+GLlP30S+vfV9XZJhxncTUFTl/E5p/MXQNdwquzwWSPR6I7/vkM7uM2X8xROPdtwUAyMOU8QfBxyDQSwAa25Dh/lrus+G+rgCxQSCeAh41DAPBF0PQMwwHSmyekeE+Wu5fw2dl+NFDVyKYqSHINTnnmJGLmDShisFsltLATOmV/wStHUFFcYJuTgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img 2' title='img 2' src='/static/71d0a5f25c77b56741a5b781c61a53df/ca1dc/img_2.png' srcset='/static/71d0a5f25c77b56741a5b781c61a53df/e7570/img_2.png 170w,\n/static/71d0a5f25c77b56741a5b781c61a53df/f46e7/img_2.png 340w,\n/static/71d0a5f25c77b56741a5b781c61a53df/ca1dc/img_2.png 680w,\n/static/71d0a5f25c77b56741a5b781c61a53df/02d09/img_2.png 1020w,\n/static/71d0a5f25c77b56741a5b781c61a53df/9d567/img_2.png 1360w,\n/static/71d0a5f25c77b56741a5b781c61a53df/c1e63/img_2.png 1680w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>이처럼 <strong>하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때 항상 같은 결과를 가져오지 못하는 <code class=\"language-text\">None-Repetable Read</code>가 발생하게 됩니다.</strong></p>\n<p>또한 Read Committed 레벨에서는 <code class=\"language-text\">Record Lock</code>만을 사용하기 때문에 <strong>데이터가 중간에 삽입, 삭제 될 경우 SELECT의 결과가 다르게 나타나는 <code class=\"language-text\">Phantom Read</code> 현상도 발생</strong>하게 됩니다.</p>\n<h3>REPEATABLE READ</h3>\n<p><code class=\"language-text\">Repeatable Read</code>는 트랜잭션 범위 내에서 조회한 내용이 항상 동일함을 보장합니다. 여기서 <code class=\"language-text\">Read Committed</code>와 다른 점은 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전의 버전을 찾는지에 있습니다. 모든 <code class=\"language-text\">InnoDB</code>의 트랜잭션은 고유한 트랜잭션 번호를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있습니다.</p>\n<p>밑의 그림과 같이 자신의 트랜잭션 번호보다 작은 트랜잭션 번호만 보게 되는 것을 확인할 수 있습니다. 이를 통해 처음 생성된 <code class=\"language-text\">Snapshot</code>을 기반으로 하나의 트랜잭션 내에서 일관된 읽기를 제공합니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/917c5a252b1ba1278e013bf682c3e18b/c1e63/img_3.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 74.70588235294117%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABqklEQVQ4y31TibKCMAz0/7/wOaNyiaAUyiU35mX7CFPEZ2eipcdmN5seiMfr9TIhw55/G3LOvn/AzzRN1Pf95tA8z1QUBT2fT8rzfBNVVdH9fqfT6UTX65Wi282cXwHHcaS2bTeASPJ4PEhrTVEUmbnrunQ+nylRin6OR3IvFwOoOQnObwCFoS1nGAazjsMIfHf8rZhdmWVUcbKaQyfJFhB0wSLhDUhqmmZljX/IxtpftFTw2ZTZKceh3HNJeR5NtmQAhmFIHm8AtOs6cxlJ0jSlG9cojmOzD8lyWUbPzJF4xxD1AGBd14adsMIcSWRNXJV6d4uSFXCwMsgQU1ACh6WBnWIz4K6cXQE52QYQl8uyNAbYLsNhrAMoYxMgOwiCtUVWyXxvBwipABBZ0kafBhihhUIuEeqbcrJ/28ZubMiDZBiGGoMdgMAYbBPeF/Y7QGR9b2y8FARMQuvgIpRg/lXyJ0AwFLdhDpi0Szs1b+Xo+f4O8NPTgyzUFTJ93zdO4/0qlt/ojNpcm9CccGfKew3xPy6Z7ac38HeVMGOHX4rLLyXwKWNz5qWGv6C2i5sxqYuZAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img 3' title='img 3' src='/static/917c5a252b1ba1278e013bf682c3e18b/ca1dc/img_3.png' srcset='/static/917c5a252b1ba1278e013bf682c3e18b/e7570/img_3.png 170w,\n/static/917c5a252b1ba1278e013bf682c3e18b/f46e7/img_3.png 340w,\n/static/917c5a252b1ba1278e013bf682c3e18b/ca1dc/img_3.png 680w,\n/static/917c5a252b1ba1278e013bf682c3e18b/02d09/img_3.png 1020w,\n/static/917c5a252b1ba1278e013bf682c3e18b/9d567/img_3.png 1360w,\n/static/917c5a252b1ba1278e013bf682c3e18b/c1e63/img_3.png 1680w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p><code class=\"language-text\">Repeatable Read</code> 는 일반적인 SQL 표준에서는 <code class=\"language-text\">Phantom Read</code>가 발생하게 됩니다. 밑의 사진을 보게되면 조회를 하기 위해서 <code class=\"language-text\">SELECT … FOR UPDATE</code> 쿼리를 사용하고 있습니다. <code class=\"language-text\">FOR UPDATE</code> 쿼리를 사용하게 되면 레코드에 쓰기 잠금을 걸어버리게 되는데, 언두 레코드에는 이를 적용할 수 없습니다. 이 때문에, 언두 영역의 변경 전 데이터(Snapshot)를 가져오는 것이 아니라, 현재 레코드의 값을 가져오게 되어 <code class=\"language-text\">Phantom Read</code>가 발생한다고 할 수 있습니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 631px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/61351edc58d71e84ef8858479aac81ab/077d3/img_4.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 79.41176470588235%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABuElEQVQ4y52UW2/CMAyF9///GbAHxBt3GLfSFijQO209f5HS0ZZt2ixZTZrk+PjYyVtVVWLNjp///cU498bg8Xh0wIqikDiOJU1TiaLIjHHGeZ6bM77vi+d5crlczD7MALKxLMsG4O12k8PhIMfjUdbrtex2O1ksFjKZTGSz2Uiv15P3wUCGw6HM53MJw/ALMEmSDnUAcRhcr9d67Ku76rv9XhwNlirbXNlaDANIGvf7XbIsM47BmLRJrf6qlxosOp+lCAIJlDUeK3CkAWtAwEgv0E1WD1hZfVhzHEf2yupD0410rUJTXcsUqNB0YyVVA3IYbVarlXiuZ9IDyHVdA4SfTiej3XQ6lbgt0ZNsBhBBOQwQ7Egb1mdNDSCYE5Q5lbWyoDWOPA1AW/L/GqCdosDC9iMRbfRXTc4/CmW/HYakTDoAs4AzRzukQDv6kH5cLpemN/v9voxGI9ODzBuA7T60lafKbMZtUWazmQli9YSMvUUNwPZNsa2DA85B2+zMf9SwDfjb40CwxqPSbptXDJ+L0i5QqAwf3Co9lys43kiZYrQBv2sPLKdfeTjGY/FV02S7lVC7BPsEdgfatlWQFHYAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img 4' title='img 4' src='/static/61351edc58d71e84ef8858479aac81ab/077d3/img_4.png' srcset='/static/61351edc58d71e84ef8858479aac81ab/e7570/img_4.png 170w,\n/static/61351edc58d71e84ef8858479aac81ab/f46e7/img_4.png 340w,\n/static/61351edc58d71e84ef8858479aac81ab/077d3/img_4.png 631w' sizes='(max-width: 631px) 100vw, 631px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>하지만 저희가 주로 사용하는 MySQL의 <code class=\"language-text\">InnoDB</code> <strong>기준으로는 <code class=\"language-text\">Repetable Read</code> 조건에서 <code class=\"language-text\">Phantom Read</code>가 발생하지 않습니다.</strong> 그 이유는 Locking Read와 UPDATE, DELETE 문의 경우 검색 조건에 따라 사용되는 <code class=\"language-text\">Lock</code>이 다르게 적용되기 때문입니다.</p>\n<ul>\n<li>고유한 검색 조건이 있는 고유 인덱스에 대한 쿼리는 Record Lock이 적용</li>\n<li>범위 검색 조건의 경우 스캔한 인덱스 범위에 Gap Lock과 Next-key Lock이 적용</li>\n</ul>\n<p>이러한 이유 때문에 중간에 특정 데이터가 추가 혹은 변경되어 발생하는 <code class=\"language-text\">Phantom Read</code> 현상은 <code class=\"language-text\">InnoDB</code>의 <code class=\"language-text\">Repetable Read</code>에서는 발생하지 않습니다.</p>\n<blockquote>\n<p>그럼에도 발생할 수 있는 <code class=\"language-text\">Phantom Read</code></p>\n</blockquote>\n<p>일반적으로는 거의 발생하지 않지만 <code class=\"language-text\">Repetable Read</code> 수준임에도 불구하고 <code class=\"language-text\">Phantom Read</code>가 발생할 수 있는 상황이 있습니다.</p>\n<p>B 트랜잭션이 추가한 레코드에 A 트랜잭션이 UPDATE 쿼리를 수행하게 될 경우, 처음 SELECT 쿼리로 생성된 <code class=\"language-text\">Snapshot</code> 에는 존재하지 않지만 실제 디스크에는 데이터가 존재하기 때문에 해당 레코드가 영향을 받게 됩니다. 이후 SELECT 쿼리를 수행할 때 <code class=\"language-text\">Snapshot</code>이 초기화되어 <code class=\"language-text\">Phantom Read</code>가 발생하게 됩니다.</p>\n<p>하지만 해당 상황은 조금 억지스럽게 <code class=\"language-text\">Phantom Read</code>가 발생할 수 있는 상황을 연출한 것이라 해당 상황이 생길 수 있다는 것만 인지를 하고 넘어가도록 하겠습니다.</p>\n<h3>Serializable</h3>\n<p>가장 단순한 격리 수준이면서, 가장 엄걱한 격리 수준입니다. 일반적인 읽기 작업에 대해서도 <code class=\"language-text\">S-Lock</code>을 획득해야 하며, 동시에 다른 트랜잭션은 해당 레코드의 변경이 불가능 합니다. 이 때문에 한 트랜잭션에서 읽고 쓰고 있는 레코드에 대해서는 다른 트랜잭션에서 절대 접근할 수 없습니다.</p>\n<p>하지만 일반적인 읽기 작업에 대해서도 <code class=\"language-text\">S-Lock</code>을 통해 블로킹 처리를 수행하기 때문에 동시성이 매우 떨어지게 되어 사용하는 것을 권장하지 않습니다.</p>\n<h2>스프링에서의 트랜잭션</h2>\n<p>이처럼 트랜잭션은 위에서 설명한 트랜잭션의 격리 레벨을 이용하여 트랜잭션의 원칙 중 하나인 격리성을 수행한다고 할 수 있습니다. 그렇다면 스프링에서는 이러한 트랜잭션을 어떤 방식을 통해 구현하고 있을까요??</p>\n<h3>스프링이 제공하는 트랜잭션 기술</h3>\n<p>JDBC를 사용하는 개발자가 직접 여러 개의 작업을 하나의 트랜잭션으로 관리하기 위해서는 Connection 객체를 공유하는 작업을 추가적으로 해주어야 합니다. 이러한 로직을 매번 개발자가 작성해주어야 하기 때문에 상당히 불편한 작업이라고 할 수 있습니다.</p>\n<p>Spring은 이러한 문제를 해결하기 위해 트랜잭션을 동기화 하는 기술을 제공하고 있습니다. <code class=\"language-text\">TransactionSynchronizeManager</code>을 통해서 트랜잭션을 시작하기 위한 Connection 객체를 특정 저장소에 보관해 두고 필요할 때 꺼내서 사용하는 방식으로 동기화를 적용할 수 있습니다. 또한 해당 동기화는 작업 스레드마다 Connection 객체를 독립적으로 관리하기 때문에 멀티 스레드 환경에서도 문제가 발생할 여지 없이 Connection 객체를 공유할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">TransactionSynchronizeManager</span><span class=\"token punctuation\">.</span><span class=\"token function\">initSynchronization</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Connection</span> connection <span class=\"token operator\">=</span> <span class=\"token class-name\">DataSourceUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">getConnection</span><span class=\"token punctuation\">(</span>dataSource<span class=\"token punctuation\">)</span></code></pre></div>\n<p>하지만 해당 코드는 JDBC만 사용했을 때 유효합니다. 만약 JPA로 코드를 변경해야 한다면 기존의 Connection을 획득하는 코드를 변경해야 할 것입니다.</p>\n<p>Spring은 이러한 문제를 해결하기 위해 트랜잭션을 추상화 하는 기술을 제공하고 있습니다. <code class=\"language-text\">PlatformTransactionManger</code>를 통해서 각 트랜잭션 기술들의 공통점을 담은 트랜잭션 추상화 기술을 이용해 일관되게 트랜잭션을 처리할 수 있도록 기능을 제공합니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/8677ee7577aa52a9c3609d7ba9916ab1/f97d7/img_5.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 54.70588235294118%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtklEQVQoz21S7XKbMBDkaTpICDBTx7EFNmC+EzBfjt04M+37P8VWOsBx2vzY4bR3t+hWZ1iWhQWO42AbP2MjNwiCPaTvYyclpPTh+wFxfhAQR9jtYNs2HjWMJeCcw3UdRO+qsZIoyhcMb78wXm/oz1fCeP3AeLnR93L7TTWOEtS9/wlqCCHguR5htXIVVnBtF0/hGuv9TzjCufOe59FX93x7Q7qlxelvC4hjHMITECtB8TLNY823goKrJq794GCMqWZGDcxksGxOmLgpd69REOIfQVvYOIw+9rVEWdXoxgtO/Rn1qUM7vKFuOhX3qNseTTcQ1w5nNOqs66Iovj+OoccUloBMt9hFWxwOIdK8JByTDEmSI6tL5HWFNC0Ur5AVyIoKuXqUonpVWyDJSz2RMXmnrssU+EQyZhL0eOYPE85GwH4SFGuO8uYMFX/xUGiC8S9CbPZoAbfYLPTpH2OP56mHBNdZhed4jzAMkaQ54iRFfEyRzWNPXKJGLBHFCeW1FbqGbEmnODomtOiG3ww41Kla0vK+wBpNO2CY41M3olXm68fSy64fRMe9hspfP/6ohX9HGEX4C+j+axS8gv3HAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img 5' title='img 5' src='/static/8677ee7577aa52a9c3609d7ba9916ab1/ca1dc/img_5.png' srcset='/static/8677ee7577aa52a9c3609d7ba9916ab1/e7570/img_5.png 170w,\n/static/8677ee7577aa52a9c3609d7ba9916ab1/f46e7/img_5.png 340w,\n/static/8677ee7577aa52a9c3609d7ba9916ab1/ca1dc/img_5.png 680w,\n/static/8677ee7577aa52a9c3609d7ba9916ab1/02d09/img_5.png 1020w,\n/static/8677ee7577aa52a9c3609d7ba9916ab1/9d567/img_5.png 1360w,\n/static/8677ee7577aa52a9c3609d7ba9916ab1/f97d7/img_5.png 2000w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>또한 스프링은 각 데이터 접근 기술에 대한 트랜잭션 매니저의 구현체도 제공을 하고 있습니다. 이 때문에 우리는 필요한 구현체를 스프링 빈으로 등록하고 주입받아 사용하기만 하면 트랜잭션을 사용할 수가 있습니다. 여기에 스프링 부트까지 사용한다면 <code class=\"language-text\">AutoConfiguration</code>을 통해서 의존성으로 등록한 데이터 접근 기술을 자동으로 인식해, 적절한 트랜잭션 메니저를 스프링 빈으로 등록해주어 개발자가 사용할 수 있게 됩니다.</p>\n<h3>@Transactional 등장</h3>\n<p>이렇게 스프링에서 제공하는 동기화 기법인 <code class=\"language-text\">TransactionSynchronizeManager</code>와 추상화 기법인 <code class=\"language-text\">PlatformTransactionManager</code>를 통해서 조금 더 편리하게 개발이 가능해 졌습니다.</p>\n<p>하지만 아직까지 문제가 있습니다. 바로 비즈니스 코드와 데이터 엑세스 기술이 코드에 강하게 결합한다는 문제가 발생합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserSerivce</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">businessMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">TransactionStatus</span> status <span class=\"token operator\">=</span> transactionManager<span class=\"token punctuation\">.</span><span class=\"token function\">getTransaction</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultTransactionDefinition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">businessLogic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            transactionManager<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 성공시 커밋</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            transactionManger<span class=\"token punctuation\">.</span><span class=\"token function\">rollback</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 실패시 롤백</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이는 코드의 유지보수를 어렵게 하고 중복된 코드를 만들어 개발자의 작업 생산성을 저하시킵니다. 이러한 문제를 해결하기 스프링은 <strong>프록시 방식을 적용하여 비즈니스 코드와 데이터 엑세스 기술을 분리하여 사용할 수 있도록 기능을 제공</strong>하고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 프록시 코드</span>\n<span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TransactionUserSerivceProxy</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserService</span> target<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">businessMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">TransactionStatus</span> status <span class=\"token operator\">=</span> transactionManager<span class=\"token punctuation\">.</span><span class=\"token function\">getTransaction</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultTransactionDefinition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            target<span class=\"token punctuation\">.</span><span class=\"token function\">businessMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            transactionManager<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 성공시 커밋</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            transactionManger<span class=\"token punctuation\">.</span><span class=\"token function\">rollback</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 실패시 롤백</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 실제 비즈니스 코드</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MemberService</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">businessMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">businessLogic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또한 <strong>Advisor 기능</strong>과 <strong>동적 프록시 생성기</strong>를 이용한 <strong>트랜잭션 애노테이션(@Transactional)</strong> 을 통해 개발자가 조금 더 편하게 선언적으로 트랜잭션을 이용할 수 있도록 기능을 제공하고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Transactional</span>\n<span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MemberService</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">businessMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">businessLogic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>다음 글에서는..</h2>\n<p>이번 글에서는 트랜잭션의 관점에서 어떻게 동시성 문제를 해결하는지 살펴보고, Spring에서는 어떻게 트랜잭션을 지원하는지 그 개념과 동작원리를 살펴보는 시간을 가졌었습니다. 다음 글에서는 실제 주어진 요구사항을 해결하기 위해 필요한 추가적인 개념과 실제 코드를 통해 해결하는 과정을 살펴보도록 하겠습니다.</p>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html\">https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html</a></li>\n<li><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html\">https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html</a></li>\n</ul>","frontmatter":{"title":"동시성 문제 해결을 통한 제고 시스템 구현하기 - 1","date":"November 16, 2022","update":"December 05, 2022","tags":["Transactional"],"series":"동시성 문제 해결을 통한 제고 시스템 구현하기"},"fields":{"slug":"/동시성 문제 해결을 통한 제고 시스템 구현하기 - 1/","readingTime":{"minutes":23.87}}},"seriesList":{"edges":[{"node":{"id":"e0a5e2ef-ea28-5a38-8c0f-8b271b39bee8","fields":{"slug":"/동시성 문제 해결을 통한 제고 시스템 구현하기 - 1/"},"frontmatter":{"title":"동시성 문제 해결을 통한 제고 시스템 구현하기 - 1"}}}]},"previous":{"fields":{"slug":"/DAO와-Repository/"},"frontmatter":{"title":"DAO와 Repository"}},"next":null},"pageContext":{"id":"e0a5e2ef-ea28-5a38-8c0f-8b271b39bee8","series":"동시성 문제 해결을 통한 제고 시스템 구현하기","previousPostId":"c4eb0572-f278-5d08-9052-32b5b549b9bb","nextPostId":null}},"staticQueryHashes":[]}