{"componentChunkName":"component---src-templates-post-jsx","path":"/Transactional과-Lock-1/","result":{"data":{"site":{"siteMetadata":{"title":"rookie"}},"markdownRemark":{"id":"d0b1bfd4-e5bc-5544-8671-7428d41327c9","excerpt":"들어가기에 앞서.. 해당 학습은 “쿠폰의 재고 시스템은 어떻게 구현해야 할까?”에서 시작되었습니다. 여러명이 쿠폰을 발급받게 될 경우 어떻게 동시성 처리를 해야하는지 다양한 방법을 한번 눈으로 확인해보고 싶어서 학습을 진행하게 되었습니다. 이번 글에서는 동시성 처리에 필요한 Transactional과 DB Lock, 그리고 스프링 Transactional…","html":"<h2>들어가기에 앞서..</h2>\n<p>해당 학습은 <strong>“쿠폰의 재고 시스템은 어떻게 구현해야 할까?”</strong>에서 시작되었습니다. 여러명이 쿠폰을 발급받게 될 경우 어떻게 동시성 처리를 해야하는지 다양한 방법을 한번 눈으로 확인해보고 싶어서 학습을 진행하게 되었습니다.</p>\n<p>이번 글에서는 동시성 처리에 필요한 Transactional과 DB Lock, 그리고 스프링 Transactional이 개념에 대해서 이를 알아보는 시간을 가져보려고 합니다.</p>\n<h2>Transactional의 개념과 격리레벨</h2>\n<h3>트랜잭션이란?</h3>\n<p><strong>트랜잭션은 데이터베이스 상태를 변화시키는 하나의 논리적인 작업기능을 구성하는 단위</strong>를 말합니다. 어떤 작업들이 성공적으로 완료되어야 구성된 작업의 결과를 반영하고, 오류가 발생했을 때는 이전에 있었던 모든 작업들이 성공적이라고 해도 없었던일 처럼 완전히 되돌리는 것이 트랜잭션의 개념이라고 할 수 있습니다.</p>\n<h3>Lock과 Consistent Read</h3>\n<p>트랜잭션의 격리 레벨에 대해서 알아보기 전에 꼭 알아야 할 2가지의 개념을 먼저 알아보도록 하겠습니다.</p>\n<br>\n<p>첫번째로 알아볼 내용은 <code class=\"language-text\">Lock</code>입니다. <code class=\"language-text\">**Lock</code>은 트랜잭션 처리의 순차성을 보장하기 위한 방법**입니다.</p>\n<p>이러한 <code class=\"language-text\">Lock</code>의 적용 요소로는 대표적으로 <strong>공유 락(Shared Lock)</strong>과 <strong>베타 락(Exclusive Lock)</strong>이 있습니다.</p>\n<p><strong>공유 락</strong>은 데이터를 읽을 때 사용되는 Lock 입니다. 이러한 공유 락이 설정된 데이터는 <strong>읽는 것은 여러 사용자가 동시에 할 수 있지만, 변경은 할 수 없습니다</strong>. 또한, 변경이 안되기 때문에 당연히 베타 락 또한 설정할 수 없습니다.</p>\n<p><strong>베타 락</strong>은 데이터를 변경할 때 사용되는 Lock 입니다. 이러한 베타 락이 설정된 데이터는 읽기와 쓰기 모두 다 여러 사용자가 접근을 할 수 없습니다. 즉, 베타 락이 해제될 때까지 다른 트랜잭션은 해당 리소스에 접근이 불가능하다고 할 수 있습니다. 이렇게 Lock에 대해서 살펴본 이유는 <code class=\"language-text\">**InnoDB</code>에서 각각의 격리 레벨을 적용하기 위해서 Lock을 적용하기 때문**입니다.</p>\n<br>\n<p>또한 <code class=\"language-text\">Lock</code>은 적용되는 상황에 따라서도 분류할 수 있습니다. 대표적으로 <strong>Record Lock</strong>, <strong>Gap Lock</strong>, <strong>Next-Key Lock</strong> 이 있습니다.</p>\n<p><strong>Record Lock</strong>은 primary key, unique index로 조회해서 <strong>하나의 인덱스 레코드에만 Lock을 거는 것</strong>을 말합니다. 이러한 인덱스 레코드에는 S-Lock, X-Lock을 사용할 수 있습니다.</p>\n<p><strong>Gap Lock</strong>은 범위를 지정하기 위해 <strong>인덱스 레코드 사이 범위에 락을 거는 것</strong>을 의미합니다. 최초 레코드 이전, 마지막 레코드 이후를 가상의 인덱스 레코드로 생각해서 Lock을 적용하는 것이 가능합니다. Gap Lock은 상황에 따라서 Record Lock으로 동작을 할 수도 있습니다.</p>\n<ul>\n<li>컬럼에 unique index가 걸려있는 경우 Record Lock이 사용된다.</li>\n<li>컬럼에 index가 걸려있지 않거나, index가 걸려 있어도 unique 하지 않으면 Gap Lock이 사용된다. (index가 걸려 있다면 Row를 찾기 위해 스캔했던 index range에 대한 Gap Lock 적용, index가 걸려있지 않다면 결국 테이블 전체를 스캔해야 해서 모든 row에 대해 Lock이 발생해 Gap Lock 적용)</li>\n</ul>\n<p><strong>Next-Key Lock</strong>은 실제 범위 지정 쿼리를 실행하면 위에서 설명한 Record Lock, Gap Lock이 복합적으로 발생하는 Lock 입니다.</p>\n<br>\n<p>두번째로 알아볼 내용은 <code class=\"language-text\">Consistent Read</code> 입니다. <strong><code class=\"language-text\">Consistent Read</code>는 트랜잭션 내부에서 동시에 실행중인 다른 트랙잭션에 데이터를 변경하더라도 특정 시점의 Snapshot을 이용해 기존과 동일한 결과를 리턴</strong>할 수 있도록 해주는 기능을 말합니다. 이를 통해서, <strong>Lock이 필요한 부분에서 Lock을 사용하지 않고도 동시성 제어를 할 수 있게 됩니다.</strong></p>\n<h3>트랜잭션의 격리 레벨이란 무엇인가?</h3>\n<p>트랜잭션 격리 레벨이란 <strong>동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것</strong>입니다. 즉, 특정 트랜잭션이 다른 트랜잭션에 변경할 데이터를 볼 수 있도록 허용할지 말지를 결정합니다.</p>\n<p>이를 수행하기 위해서, 트랜잭션이 독립적인 수행을 하도록 <code class=\"language-text\">Locking</code>을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 작업이 필요합니다.</p>\n<p>하지만 무조건적인 <code class=\"language-text\">Locking</code>으로 동시에 수행되는 수많은 트랜잭션을 순서대로 처리하도록 설계하게 되면 데이터베이스의 동시성 성능이 떨어지게 됩니다. 이러한 성능저하를 줄이기 위해서 <code class=\"language-text\">Locking</code>의 범위를 줄인다면, 데이터 일관성이 깨지는 문제가 발생할 수도 있습니다. 따라서 최대한 효율적으로 <code class=\"language-text\">Locking</code>을 설정하는 것이 좋습니다.</p>\n<h2>트랜잭션 격리 레벨에 대해서 자세히 알아보자</h2>\n<p>트랜잭션 격리 레벨은 다음과 같이 4단계로 구분을 할 수 있습니다.</p>\n<ul>\n<li>READ UNCOMMITTED</li>\n<li>READ COMMITTED</li>\n<li>REPEATABLE READ</li>\n<li>SERIALIZABLE</li>\n</ul>\n<p>4가지 키워드들을 하나씩 살펴보도록 하겠습니다.</p>\n<h3>READ UNCOMMITTED</h3>\n<p><code class=\"language-text\">Read Uncommitted</code>는 커밋 전의 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 읽는 것을 허용하는 격리 레벨을 말합니다. <code class=\"language-text\">Read Uncommitted</code> 에서는 <code class=\"language-text\">Dirty Read</code>현상이 발생할 수 있습니다.</p>\n<p><code class=\"language-text\">Transaction 1</code>에서 INSERT로 추가된 <code class=\"language-text\">Coupon</code>이 <code class=\"language-text\">COMMIT</code> 되기 이전에 새로운 <code class=\"language-text\">Transaction 2</code>에서 <code class=\"language-text\">Coupon</code>을 조회한다고 가정해보겠습니다. 하지만 <code class=\"language-text\">Transaction 1</code>에서 오류가 발생해서 <code class=\"language-text\">ROLLeBACK</code>이 되게 되었습니다. 이 경우 <code class=\"language-text\">Transaction 2</code>는 <code class=\"language-text\">ROLLBACK</code> 여부를 확인하지 못하고 <code class=\"language-text\">ROLLBACK</code> 된 <code class=\"language-text\">Coupon</code>를 정상적인 데이터라 생각하고 작업을 계속 진행하게 됩니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/1c58f2297bbd2ee4528da955e586337f/c1e63/img.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 69.41176470588235%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWElEQVQ4y5WTcY+CMAzF/f7fzz88LhEvAQkiCIKAoHW/Jl244SVek2ZvrH3rXsvm+XwK9ng8xPAnZrHLHPDGNsfjUS6Xi9zvdxmGQX0cR+n7Xr+BzUMyzud5VqyE0zRJXddyu9300EjLspT9fi9N0yjebreS57lP5lUYl8LhCTlIkkSKovBVdV2neFktpGAIl09dEbKhqtC4yLRdrmZVVYnlrwi5xXQx/8uoMssyOcSxrhCvNCQo7F7btprAGRhZrteraho7stTtM9fMjwj5RtdpAg0DQ3I+n708Fju80zAkRCvTlpUKmAKTB9w7z6Mvyb4jr+1bwv8MODa63FWFjEXYFKsyxOi52+0kdjNKY5az6QmZu2VlEDCX6IZ+4CiKNJlYdK3dXELeOF8NdpqmmoQ+OIGsSGErxHauv6PzJk3k9HP4XWH4THOCbLW/w76Zt8VJuqr0cr0AWyJHCzi8MkAAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img' title='img' src='/static/1c58f2297bbd2ee4528da955e586337f/ca1dc/img.png' srcset='/static/1c58f2297bbd2ee4528da955e586337f/e7570/img.png 170w,\n/static/1c58f2297bbd2ee4528da955e586337f/f46e7/img.png 340w,\n/static/1c58f2297bbd2ee4528da955e586337f/ca1dc/img.png 680w,\n/static/1c58f2297bbd2ee4528da955e586337f/02d09/img.png 1020w,\n/static/1c58f2297bbd2ee4528da955e586337f/9d567/img.png 1360w,\n/static/1c58f2297bbd2ee4528da955e586337f/c1e63/img.png 1680w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>이처럼 트랜잭션에서 처리한 작업이 완료되지 않아도 볼 수 있는 현상을 <code class=\"language-text\">Dirty Read</code>라고 합니다.</p>\n<h3>READ COMMITTED</h3>\n<p><code class=\"language-text\">Read Committed</code>는 <code class=\"language-text\">COMMIT</code>이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회가 가능합니다. 이로 인해서, <code class=\"language-text\">Read Uncommitted</code>에서 발생하는 <code class=\"language-text\">Dirty Read</code>가 발생하지 않습니다. 이렇게 되는 이유는 <code class=\"language-text\">Read Committed</code> 부터는 <code class=\"language-text\">MVCC</code>인 <code class=\"language-text\">Consistent Read</code>로 문제를 해결하기 때문인데요.</p>\n<p><code class=\"language-text\">Read Committed</code>에서 데이터의 변경이 일어나게 되면 변경 전 데이터는 <strong>언두 영역으로 복사가 됩니다</strong>. 그리고 <strong>다른 트랜잭션에서 해당 테이블의 데이터를 조회할 경우, 변경된 테이블 데이터를 조회하는 것이 아니라 언두 영역에 복사된(Snapshot) 레코드를 조회</strong>하게 됩니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/70f38cbbad9f0e4729e7d1b5abb1f338/c1e63/img_1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 69.41176470588235%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcklEQVQ4y42T6Y7CMAyEef/3Q/wAlkM9OAq9aGlLqTefhVFaVmgjWXESezwTJ7NhGITxfD7F/P8Mi/Vz8Ge2iONYsiyTruukaRq1tm3lfr/rHr7ZFIzzvu/VV8DH4yF5nktd13pooNfrVTabjRRFof58PpfT6fRONkCKgvEGRG4YhpIkiQIRUFXViBVF0jTVcwB9qeyNAH3K/qAQZyTjk+THocjyR4AEUR1pVDOwy+Ui2+1WrwP2y+VSJcOYK/hZr3VN3ggQBrvdThOiKJLb7aaSrTkwYaYAYMyr1UqC/V7CINBiH00xZr48gGF3OBzkeDwqk7IspXpJtdG62BHDKaBJ5hpoFkCwWiwWyubs9nKnpHCFSmdJGHxn6DP1H/3wWtdZKlkcOYuldHeYurn/xtA3zgwcFlbEH91fkrl4/22RiDy6zA/CpxHcpcrzGH88bAII5ClwiNEQZppgezSHefpTPh62LxFmZiT6ZnvTv2y5jF+6SkToUd4HywAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img 1' title='img 1' src='/static/70f38cbbad9f0e4729e7d1b5abb1f338/ca1dc/img_1.png' srcset='/static/70f38cbbad9f0e4729e7d1b5abb1f338/e7570/img_1.png 170w,\n/static/70f38cbbad9f0e4729e7d1b5abb1f338/f46e7/img_1.png 340w,\n/static/70f38cbbad9f0e4729e7d1b5abb1f338/ca1dc/img_1.png 680w,\n/static/70f38cbbad9f0e4729e7d1b5abb1f338/02d09/img_1.png 1020w,\n/static/70f38cbbad9f0e4729e7d1b5abb1f338/9d567/img_1.png 1360w,\n/static/70f38cbbad9f0e4729e7d1b5abb1f338/c1e63/img_1.png 1680w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p><code class=\"language-text\">Read Committed</code>는 <code class=\"language-text\">COMMIT</code> 된 데이터에 대해서는 정합성을 유지한다는 판단을 하기 때문에 <code class=\"language-text\">Snapshot</code>을 해당 <code class=\"language-text\">COMMIT</code>된 데이터로 다시 덮어쓰게 됩니다.</p>\n<p><code class=\"language-text\">Read Committed</code>에서는 <code class=\"language-text\">None Repetable Read</code>현상이 발생할 수 있습니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/71d0a5f25c77b56741a5b781c61a53df/c1e63/img_2.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 69.41176470588235%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABmUlEQVQ4y41T686CMAz1/d/P+AP9vAByR9i4i9SexpqhifmWNHRbe3pOOzbLshDW4/Eg9f+zNNbNgb/RTRRFVFUVTdNEwzCIjeNIfd/LGXy1TzDcz/MsvgDe73eq65q6rpNLBS3Lko7HIxljxN9ut5Sm6TtZAVEUGG9AyA3DkPI8FyAEtG27YoUit9tN7gHoSsXZCtCl7C4Uwh2S4SPJjYMizV8BIgjVIQ3VFKwoCjqdTtIOsPc8TySDMVrwdzjIHnkrQDA4n8+ScL1eqWkakazDARN8UQBg+O73ewouFwqDQIp9DUWZufIADHZxHFOSJMLEWkvtS6qukWNXDD8BVTLagGEBCKx2u52wycKAalZiuJCJI8qZ5U+GLlP30S+vfV9XZJhxncTUFTl/E5p/MXQNdwquzwWSPR6I7/vkM7uM2X8xROPdtwUAyMOU8QfBxyDQSwAa25Dh/lrus+G+rgCxQSCeAh41DAPBF0PQMwwHSmyekeE+Wu5fw2dl+NFDVyKYqSHINTnnmJGLmDShisFsltLATOmV/wStHUFFcYJuTgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img 2' title='img 2' src='/static/71d0a5f25c77b56741a5b781c61a53df/ca1dc/img_2.png' srcset='/static/71d0a5f25c77b56741a5b781c61a53df/e7570/img_2.png 170w,\n/static/71d0a5f25c77b56741a5b781c61a53df/f46e7/img_2.png 340w,\n/static/71d0a5f25c77b56741a5b781c61a53df/ca1dc/img_2.png 680w,\n/static/71d0a5f25c77b56741a5b781c61a53df/02d09/img_2.png 1020w,\n/static/71d0a5f25c77b56741a5b781c61a53df/9d567/img_2.png 1360w,\n/static/71d0a5f25c77b56741a5b781c61a53df/c1e63/img_2.png 1680w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>DB에는 <code class=\"language-text\">Coupon</code>이 2개가 있다고 가정해보겠습니다. <code class=\"language-text\">Transaction 1</code>에서 쿼리가 먼저 시작되고 나서 <code class=\"language-text\">Transaction 2</code>에서 <code class=\"language-text\">Coupon</code> 의 2번 ID를 조회하면 <strong>커피가 조회가 되게 됩니다</strong>. 하지만 <code class=\"language-text\">Transcation 1</code>에서 <strong>UPDATE</strong> 쿼리가 <code class=\"language-text\">COMMIT</code> 된 이후 <code class=\"language-text\">Transaction 2</code> 에서 다시 똑같은 <strong>SELECT</strong> 쿼리를 사용하여 다시 <code class=\"language-text\">Coupon</code>를 조회하게 될 경우 <strong>UPDATE</strong> 쿼리의 경우 <strong>술이 조회가 되게 됩니다.</strong></p>\n<p>이처럼 <strong>하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때 항상 같은 결과를 가져오지 못하는 <code class=\"language-text\">None-Repetable Read</code>가 발생하게 됩니다.</strong></p>\n<p>또한 앞서서 설명드렸듯이 Lock 방법에서 <code class=\"language-text\">Record Lock</code>만을 사용하기 때문에 <strong>데이터가 중간에 삽입, 삭제 될 경우 SELECT의 결과가 다르게 나타나는 <code class=\"language-text\">Phantom Read</code> 현상도 발생</strong>하게 됩니다.</p>\n<h3>REPEATABLE READ</h3>\n<p><code class=\"language-text\">Repeatable Read</code>는 트랜잭션 범위 내에서 조회한 내용이 항상 동일함을 보장합니다. 여기서 <code class=\"language-text\">Read Committed</code>와 다른 점은 <strong>언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾는지</strong>에 있습니다. 모든 <code class=\"language-text\">InnoDB</code>의 트랜잭션은 고유한 트랜잭션 번호를 가지며, <strong>언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함</strong>되어 있습니다.</p>\n<p>밑의 그림과 같이 <strong>자신의 트랜잭션 번호보다 작은 트랜잭션 번호만 보게 되는 것을 확인</strong>할 수 있습니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/917c5a252b1ba1278e013bf682c3e18b/c1e63/img_3.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 74.70588235294117%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABqklEQVQ4y31TibKCMAz0/7/wOaNyiaAUyiU35mX7CFPEZ2eipcdmN5seiMfr9TIhw55/G3LOvn/AzzRN1Pf95tA8z1QUBT2fT8rzfBNVVdH9fqfT6UTX65Wi282cXwHHcaS2bTeASPJ4PEhrTVEUmbnrunQ+nylRin6OR3IvFwOoOQnObwCFoS1nGAazjsMIfHf8rZhdmWVUcbKaQyfJFhB0wSLhDUhqmmZljX/IxtpftFTw2ZTZKceh3HNJeR5NtmQAhmFIHm8AtOs6cxlJ0jSlG9cojmOzD8lyWUbPzJF4xxD1AGBd14adsMIcSWRNXJV6d4uSFXCwMsgQU1ACh6WBnWIz4K6cXQE52QYQl8uyNAbYLsNhrAMoYxMgOwiCtUVWyXxvBwipABBZ0kafBhihhUIuEeqbcrJ/28ZubMiDZBiGGoMdgMAYbBPeF/Y7QGR9b2y8FARMQuvgIpRg/lXyJ0AwFLdhDpi0Szs1b+Xo+f4O8NPTgyzUFTJ93zdO4/0qlt/ojNpcm9CccGfKew3xPy6Z7ac38HeVMGOHX4rLLyXwKWNz5qWGv6C2i5sxqYuZAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img 3' title='img 3' src='/static/917c5a252b1ba1278e013bf682c3e18b/ca1dc/img_3.png' srcset='/static/917c5a252b1ba1278e013bf682c3e18b/e7570/img_3.png 170w,\n/static/917c5a252b1ba1278e013bf682c3e18b/f46e7/img_3.png 340w,\n/static/917c5a252b1ba1278e013bf682c3e18b/ca1dc/img_3.png 680w,\n/static/917c5a252b1ba1278e013bf682c3e18b/02d09/img_3.png 1020w,\n/static/917c5a252b1ba1278e013bf682c3e18b/9d567/img_3.png 1360w,\n/static/917c5a252b1ba1278e013bf682c3e18b/c1e63/img_3.png 1680w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>일반적인 SQL 표준에서는 <code class=\"language-text\">Repetable Read</code> 조건일 때, <code class=\"language-text\">Phantom Read</code>가 발생하게 됩니다. 상황은 다음과 같습니다. 위에서 조회를 하기 위해서 <code class=\"language-text\">SELECT … FOR UPDATE</code> 쿼리를 사용하고 있습니다. <code class=\"language-text\">**FOR UPDATE</code> 쿼리를 사용하게 되면 레코드에 쓰기 잠금을 걸어버리게 되는데, 언두 레코드에는 이를 적용할 수 없습<strong>니다. 이로 인해서, 언두 영역의 변경 전 데이터를 가져오는 것이 아니라, **현재 레코드의 값을 가져오게 되어 <code class=\"language-text\">Phantom Read</code>가 발생</strong>한다고 할 수 있습니다.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 631px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/61351edc58d71e84ef8858479aac81ab/077d3/img_4.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 79.41176470588235%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABuElEQVQ4y52UW2/CMAyF9///GbAHxBt3GLfSFijQO209f5HS0ZZt2ixZTZrk+PjYyVtVVWLNjp///cU498bg8Xh0wIqikDiOJU1TiaLIjHHGeZ6bM77vi+d5crlczD7MALKxLMsG4O12k8PhIMfjUdbrtex2O1ksFjKZTGSz2Uiv15P3wUCGw6HM53MJw/ALMEmSDnUAcRhcr9d67Ku76rv9XhwNlirbXNlaDANIGvf7XbIsM47BmLRJrf6qlxosOp+lCAIJlDUeK3CkAWtAwEgv0E1WD1hZfVhzHEf2yupD0410rUJTXcsUqNB0YyVVA3IYbVarlXiuZ9IDyHVdA4SfTiej3XQ6lbgt0ZNsBhBBOQwQ7Egb1mdNDSCYE5Q5lbWyoDWOPA1AW/L/GqCdosDC9iMRbfRXTc4/CmW/HYakTDoAs4AzRzukQDv6kH5cLpemN/v9voxGI9ODzBuA7T60lafKbMZtUWazmQli9YSMvUUNwPZNsa2DA85B2+zMf9SwDfjb40CwxqPSbptXDJ+L0i5QqAwf3Co9lys43kiZYrQBv2sPLKdfeTjGY/FV02S7lVC7BPsEdgfatlWQFHYAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img 4' title='img 4' src='/static/61351edc58d71e84ef8858479aac81ab/077d3/img_4.png' srcset='/static/61351edc58d71e84ef8858479aac81ab/e7570/img_4.png 170w,\n/static/61351edc58d71e84ef8858479aac81ab/f46e7/img_4.png 340w,\n/static/61351edc58d71e84ef8858479aac81ab/077d3/img_4.png 631w' sizes='(max-width: 631px) 100vw, 631px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>하지만 저희가 주로 사용하는 MySQL의 <code class=\"language-text\">**InnoDB</code> 기준으로는 <code class=\"language-text\">Repetable Read</code> 조건에서 <code class=\"language-text\">Phantom Read</code>가 발생하지 않습니다. 그 이유는 InnoDB에서 <code class=\"language-text\">Record Lock</code> 혹은 <code class=\"language-text\">Next-key Lock</code>을 사용해서 <code class=\"language-text\">Phantom Read</code>를 방지하기 때문**입니다.</p>\n<p>특정 레코드에 대해서만 <code class=\"language-text\">Lock</code>을 걸지 않고 검색하고자 하는 범위 내에서 <code class=\"language-text\">Gap Lock</code>까지 걸어버리기 때문에 중간에 특정 데이터가 <strong>추가 혹은 삭제되어 발생하는 <code class=\"language-text\">Phantom Read</code> 현상은 발생</strong>하지 않습니다.</p>\n<h3>Serializable</h3>\n<p>가장 단순한 격리 수준이면서, 가장 엄걱한 격리 수준입니다. 읽기 작업에 대해서도 공유 잠금을 획득해야 하며, 동시에 다른 트랜잭션은 해당 레코드의 변경이 불가능 합니다. 즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없습니다.</p>\n<p>MySQL <code class=\"language-text\">InnoDB</code>에서의 격리수준에서 가장 아리송할 수 있는 부분은 <code class=\"language-text\">Repetable Read</code>와 <code class=\"language-text\">Serializable</code> 둘다 <code class=\"language-text\">Phantom Read</code>가 발생하지 않도록 보장한다는 점입니다. <strong>여기서 주의깊게 봐야 할 점은 그 보장의 방법이 다르다는 점입니다.</strong></p>\n<p><code class=\"language-text\">Repetable Read</code>는 Write 상황에서는 <code class=\"language-text\">x-lock</code>이 걸리고 Read 상황에서는 <code class=\"language-text\">Consistent Read</code>를 통해서 비 잠금 Read로 <code class=\"language-text\">Phantom Read</code> 가 발생하지 않도록 보장합니다.</p>\n<p>반면 <code class=\"language-text\">Serializable</code>은 <code class=\"language-text\">Consistent Read</code>를 사용하지 않고, Read를 수행할 때도 <code class=\"language-text\">s-lock</code>을 걸어서 <code class=\"language-text\">Phantom Read</code>가 발생하지 않도록 보장하게 된다는 점이 차이가 있다고 할 수 있습니다.</p>\n<h2>스프링에서의 트랜잭션</h2>\n<h3>스프링에서의 트랜잭션 작동 원리</h3>\n<p>각각의 데이터 접근 기술들(JDBC, JPA)은 트랜잭션을 처리하는 방식에 차이가 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">jdbcTemplate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">SQLException</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Connection</span> conn <span class=\"token operator\">=</span> dataSource<span class=\"token punctuation\">.</span><span class=\"token function\">getConnection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        conn<span class=\"token punctuation\">.</span><span class=\"token function\">setAutoCommit</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// (1) - 트랜잭션 시작</span>\n        <span class=\"token function\">bizLogic</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        conn<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>             <span class=\"token comment\">// (2) - 로직 성공시 트랜잭션 커밋</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        conn<span class=\"token punctuation\">.</span><span class=\"token function\">rollback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">jpa</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">EntityManagerFactory</span> emf <span class=\"token operator\">=</span> <span class=\"token class-name\">Persistence</span><span class=\"token punctuation\">.</span><span class=\"token function\">createEntityFactory</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"transaction\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">EntityManager</span> em <span class=\"token operator\">=</span> emf<span class=\"token punctuation\">.</span><span class=\"token function\">createEntityManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">EntityTransaction</span> tx <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">getTransaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        tx<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>              <span class=\"token comment\">// (1) - 트랜잭션 시작</span>\n        <span class=\"token function\">bizLogic</span><span class=\"token punctuation\">(</span>em<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        tx<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>             <span class=\"token comment\">// (2) - 로직 성공시 트랜잭션 커밋</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        tx<span class=\"token punctuation\">.</span><span class=\"token function\">rollabck</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        em<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    emf<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 처리하는 방식에 차이가 발생하게 되면, 데이터 접근 기술이 변경될 때마다, 코드를 수정해야 하는 불편한 점이 발생하게 됩니다. 스프링은 이러한 문제를 해결하기 위해 <strong>트랜잭션 추상화를 제공</strong>합니다. <code class=\"language-text\">PlatformTransactionManager</code> 라는 인터페이스를 통해 트랜잭션을 추상화 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">PlatformTransactionManager</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">TransactionManager</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token class-name\">TransactionStatus</span> <span class=\"token function\">getTransaction</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Nullable</span> <span class=\"token class-name\">TransactionDefinition</span> definition<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">TransactionException</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TransactionStatus</span> status<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">TransactionException</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">rollback</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TransactionStatus</span> status<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">TransactionException</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또한 스프링은 <strong>데이터 접근 기술에 대한 트랜잭션 매니저의 구현체도 제공</strong>을 합니다. 이 때문에 우리는 필요한 구현체를 스프링 빈으로 등록하고 주입받아 사용하기만 하면 됩니다. 추가적으로 스프링 부트를 사용한다면 <code class=\"language-text\">AutoConfiguration</code>에 의하여 <strong>개발자가 의존성으로 등록한 데이터 접근기술을 자동으로 인식해, 적절한 트랜잭션 메니저를 스프링 빈으로 등록</strong>해 줍니다.</p>\n<h3>@Transactional 등장</h3>\n<p>앞에서 설명한 스프링에서 제공하는 트랜잭션 추상화인 <code class=\"language-text\">PlatformTransactionManger</code>를 사용하는 방식은 <strong>선언적 트랜잭션</strong> <strong>관리</strong>와 <strong>프로그래밍 방식 트랜잭션 관리로 분류</strong>할 수 있습니다<strong>.</strong> 프로그래밍 방식의 트랜잭션 관리를 사용하게 되면, <strong>애플리케이션 코드가 트랜잭션이라는 기술 코드와 강하게 결합</strong>하게 됩니다. 이는 다음 코드를 통해서도 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserSerivce</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">TransactionStatus</span> status <span class=\"token operator\">=</span> transactionManager<span class=\"token punctuation\">.</span><span class=\"token function\">getTransaction</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultTransactionDefinition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">bizLogic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        transactionManager<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 성공시 커밋</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        transactionManger<span class=\"token punctuation\">.</span><span class=\"token function\">rollback</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 실패시 롤백</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 비즈니스 로직과 강하게 결합하는 문제를 해결하기 위해서 <strong>프록시 방식을 이용한 트랜잭션 관리 방식의 트랜잭션이 등장하게 되었습니다</strong>.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TransactionUserSerivceProxy</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserService</span> target<span class=\"token punctuation\">;</span>\n\t\t\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">logic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">TransactionStatus</span> status <span class=\"token operator\">=</span> transactionManger<span class=\"token punctuation\">.</span><span class=\"token function\">getTransaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            target<span class=\"token punctuation\">.</span><span class=\"token function\">logic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            transactionManager<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 성공시 커밋</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            transactionManger<span class=\"token punctuation\">.</span><span class=\"token function\">rollback</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 실패시 롤백</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MemberService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">logic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">bizLogic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 조금 더 발전해 스프링에서는 <code class=\"language-text\">@Transactional</code> 애노테이션을 이용해서 <strong><code class=\"language-text\">@Transactional</code>이 선언된 곳에 트랜잭션을 처리하는 프록시를 적용해 선언적 트랜잭션 관리 방식으로 사용을 할 수 있게 기능을 제공</strong>합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Transactional</span>\n<span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MemberService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">logic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">bizLogic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>1편 글을 마치며..</h2>\n<p>이번 글에서는 Transactional과 DB Lock, 그리고 스프링 Transactional이 어떻게 각 데이터 접근 기술에 대해서 트랜잭션을 지원하는지를 알아보았습니다. 다음 글에서는 이제 실제 코드를 통해서 문제 상황을 확인하고 이에 따른 해결방법을 한번 살펴보도록 하겠습니다.</p>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html\">https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html</a></li>\n</ul>","frontmatter":{"title":"Transactional과 Lock - 1","date":"November 01, 2022","update":"November 02, 2022","tags":["Transactional"],"series":"Transactional과 Lock"},"fields":{"slug":"/Transactional과-Lock-1/","readingTime":{"minutes":19.475}}},"seriesList":{"edges":[{"node":{"id":"d0b1bfd4-e5bc-5544-8671-7428d41327c9","fields":{"slug":"/Transactional과-Lock-1/"},"frontmatter":{"title":"Transactional과 Lock - 1"}}}]},"previous":{"fields":{"slug":"/DAO와-Repository/"},"frontmatter":{"title":"DAO와 Repository"}},"next":null},"pageContext":{"id":"d0b1bfd4-e5bc-5544-8671-7428d41327c9","series":"Transactional과 Lock","previousPostId":"c4eb0572-f278-5d08-9052-32b5b549b9bb","nextPostId":null}},"staticQueryHashes":[]}